// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type Ipv4Service struct {
	// Address corresponds to the JSON schema field "address".
	Address L3Ipv4Host `json:"address" yaml:"address" mapstructure:"address"`

	// Type corresponds to the JSON schema field "type".
	Type Ipv4ServiceType `json:"type" yaml:"type" mapstructure:"type"`
}

type Ipv4ServiceType string

const Ipv4ServiceTypeDns Ipv4ServiceType = "dns"

var enumValues_Ipv4ServiceType = []interface{}{
	"dns",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv4ServiceType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Ipv4ServiceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Ipv4ServiceType, v)
	}
	*j = Ipv4ServiceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv4Service) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in Ipv4Service: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Ipv4Service: required")
	}
	type Plain Ipv4Service
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Ipv4Service(plain)
	return nil
}

type Ipv4Services []Ipv4Service

type Ipv6Service struct {
	// Address corresponds to the JSON schema field "address".
	Address L3Ipv6Host `json:"address" yaml:"address" mapstructure:"address"`

	// Type corresponds to the JSON schema field "type".
	Type Ipv6ServiceType `json:"type" yaml:"type" mapstructure:"type"`
}

type Ipv6ServiceType string

const Ipv6ServiceTypeDns Ipv6ServiceType = "dns"

var enumValues_Ipv6ServiceType = []interface{}{
	"dns",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv6ServiceType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Ipv6ServiceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Ipv6ServiceType, v)
	}
	*j = Ipv6ServiceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv6Service) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in Ipv6Service: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Ipv6Service: required")
	}
	type Plain Ipv6Service
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Ipv6Service(plain)
	return nil
}

type Ipv6Services []Ipv6Service

type L2Address string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2Address) UnmarshalJSON(value []byte) error {
	type Plain L2Address
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`(?i)^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `(?i)^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$`)
	}
	*j = L2Address(plain)
	return nil
}

type L2Bond struct {
	// BondLinks corresponds to the JSON schema field "bond_links".
	BondLinks []string `json:"bond_links" yaml:"bond_links" mapstructure:"bond_links"`

	// BondMode corresponds to the JSON schema field "bond_mode".
	BondMode L2BondBondMode `json:"bond_mode" yaml:"bond_mode" mapstructure:"bond_mode"`

	// EthernetMacAddress corresponds to the JSON schema field "ethernet_mac_address".
	EthernetMacAddress L2Address `json:"ethernet_mac_address" yaml:"ethernet_mac_address" mapstructure:"ethernet_mac_address"`

	// Id corresponds to the JSON schema field "id".
	Id L2Id `json:"id" yaml:"id" mapstructure:"id"`

	// Mtu corresponds to the JSON schema field "mtu".
	Mtu L2BondMtu `json:"mtu,omitempty" yaml:"mtu,omitempty" mapstructure:"mtu,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type L2BondType `json:"type" yaml:"type" mapstructure:"type"`

	// VifId corresponds to the JSON schema field "vif_id".
	VifId *L2VifId `json:"vif_id,omitempty" yaml:"vif_id,omitempty" mapstructure:"vif_id,omitempty"`
}

type L2BondBondMode string

const L2BondBondModeA8023Ad L2BondBondMode = "802.3ad"
const L2BondBondModeActiveBackup L2BondBondMode = "active-backup"
const L2BondBondModeBalanceAlb L2BondBondMode = "balance-alb"
const L2BondBondModeBalanceRr L2BondBondMode = "balance-rr"
const L2BondBondModeBalanceTlb L2BondBondMode = "balance-tlb"
const L2BondBondModeBalanceXor L2BondBondMode = "balance-xor"
const L2BondBondModeBroadcast L2BondBondMode = "broadcast"

var enumValues_L2BondBondMode = []interface{}{
	"802.3ad",
	"balance-rr",
	"active-backup",
	"balance-xor",
	"broadcast",
	"balance-tlb",
	"balance-alb",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2BondBondMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L2BondBondMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L2BondBondMode, v)
	}
	*j = L2BondBondMode(v)
	return nil
}

type L2BondMtu interface{}

type L2BondType string

const L2BondTypeBond L2BondType = "bond"

var enumValues_L2BondType = []interface{}{
	"bond",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2BondType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L2BondType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L2BondType, v)
	}
	*j = L2BondType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2Bond) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bond_links"]; raw != nil && !ok {
		return fmt.Errorf("field bond_links in L2Bond: required")
	}
	if _, ok := raw["bond_mode"]; raw != nil && !ok {
		return fmt.Errorf("field bond_mode in L2Bond: required")
	}
	if _, ok := raw["ethernet_mac_address"]; raw != nil && !ok {
		return fmt.Errorf("field ethernet_mac_address in L2Bond: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in L2Bond: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in L2Bond: required")
	}
	type Plain L2Bond
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L2Bond(plain)
	return nil
}

type L2Id string

type L2Link struct {
	// EthernetMacAddress corresponds to the JSON schema field "ethernet_mac_address".
	EthernetMacAddress L2Address `json:"ethernet_mac_address" yaml:"ethernet_mac_address" mapstructure:"ethernet_mac_address"`

	// Id corresponds to the JSON schema field "id".
	Id L2Id `json:"id" yaml:"id" mapstructure:"id"`

	// Mtu corresponds to the JSON schema field "mtu".
	Mtu L2LinkMtu `json:"mtu,omitempty" yaml:"mtu,omitempty" mapstructure:"mtu,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type L2LinkType `json:"type" yaml:"type" mapstructure:"type"`

	// VifId corresponds to the JSON schema field "vif_id".
	VifId *L2VifId `json:"vif_id,omitempty" yaml:"vif_id,omitempty" mapstructure:"vif_id,omitempty"`
}

type L2LinkMtu interface{}

type L2LinkType string

const L2LinkTypeBridge L2LinkType = "bridge"
const L2LinkTypeDvs L2LinkType = "dvs"
const L2LinkTypeHwVeb L2LinkType = "hw_veb"
const L2LinkTypeHyperv L2LinkType = "hyperv"
const L2LinkTypeOvs L2LinkType = "ovs"
const L2LinkTypePhy L2LinkType = "phy"
const L2LinkTypeTap L2LinkType = "tap"
const L2LinkTypeVhostuser L2LinkType = "vhostuser"
const L2LinkTypeVif L2LinkType = "vif"

var enumValues_L2LinkType = []interface{}{
	"bridge",
	"dvs",
	"hw_veb",
	"hyperv",
	"ovs",
	"tap",
	"vhostuser",
	"vif",
	"phy",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2LinkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L2LinkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L2LinkType, v)
	}
	*j = L2LinkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2Link) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["ethernet_mac_address"]; raw != nil && !ok {
		return fmt.Errorf("field ethernet_mac_address in L2Link: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in L2Link: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in L2Link: required")
	}
	type Plain L2Link
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L2Link(plain)
	return nil
}

type L2Mtu interface{}

type L2VifId string

type L2Vlan struct {
	// Id corresponds to the JSON schema field "id".
	Id L2Id `json:"id" yaml:"id" mapstructure:"id"`

	// Mtu corresponds to the JSON schema field "mtu".
	Mtu L2VlanMtu `json:"mtu,omitempty" yaml:"mtu,omitempty" mapstructure:"mtu,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type L2VlanType `json:"type" yaml:"type" mapstructure:"type"`

	// VifId corresponds to the JSON schema field "vif_id".
	VifId *L2VifId `json:"vif_id,omitempty" yaml:"vif_id,omitempty" mapstructure:"vif_id,omitempty"`

	// VlanId corresponds to the JSON schema field "vlan_id".
	VlanId int `json:"vlan_id" yaml:"vlan_id" mapstructure:"vlan_id"`

	// VlanLink corresponds to the JSON schema field "vlan_link".
	VlanLink string `json:"vlan_link" yaml:"vlan_link" mapstructure:"vlan_link"`

	// VlanMacAddress corresponds to the JSON schema field "vlan_mac_address".
	VlanMacAddress L2Address `json:"vlan_mac_address" yaml:"vlan_mac_address" mapstructure:"vlan_mac_address"`
}

type L2VlanMtu interface{}

type L2VlanType string

const L2VlanTypeVlan L2VlanType = "vlan"

var enumValues_L2VlanType = []interface{}{
	"vlan",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2VlanType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L2VlanType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L2VlanType, v)
	}
	*j = L2VlanType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L2Vlan) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in L2Vlan: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in L2Vlan: required")
	}
	if _, ok := raw["vlan_id"]; raw != nil && !ok {
		return fmt.Errorf("field vlan_id in L2Vlan: required")
	}
	if _, ok := raw["vlan_link"]; raw != nil && !ok {
		return fmt.Errorf("field vlan_link in L2Vlan: required")
	}
	if _, ok := raw["vlan_mac_address"]; raw != nil && !ok {
		return fmt.Errorf("field vlan_mac_address in L2Vlan: required")
	}
	type Plain L2Vlan
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L2Vlan(plain)
	return nil
}

type L3Id string

type L3Ipv4Gateway string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Gateway) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv4Gateway
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`)
	}
	*j = L3Ipv4Gateway(plain)
	return nil
}

type L3Ipv4Host string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Host) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv4Host
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`)
	}
	*j = L3Ipv4Host(plain)
	return nil
}

type L3Ipv4Netmask string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Netmask) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv4Netmask
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(254|252|248|240|224|192|128|0)\.0\.0\.0|255\.(254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(254|252|248|240|224|192|128|0)$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(254|252|248|240|224|192|128|0)\.0\.0\.0|255\.(254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(254|252|248|240|224|192|128|0)$`)
	}
	*j = L3Ipv4Netmask(plain)
	return nil
}

type L3Ipv4Network struct {
	// Id corresponds to the JSON schema field "id".
	Id L3Id `json:"id" yaml:"id" mapstructure:"id"`

	// IpAddress corresponds to the JSON schema field "ip_address".
	IpAddress *L3Ipv4Host `json:"ip_address,omitempty" yaml:"ip_address,omitempty" mapstructure:"ip_address,omitempty"`

	// Link corresponds to the JSON schema field "link".
	Link L3Link `json:"link" yaml:"link" mapstructure:"link"`

	// Netmask corresponds to the JSON schema field "netmask".
	Netmask *L3Ipv4Netmask `json:"netmask,omitempty" yaml:"netmask,omitempty" mapstructure:"netmask,omitempty"`

	// NetworkId corresponds to the JSON schema field "network_id".
	NetworkId L3NetworkId `json:"network_id" yaml:"network_id" mapstructure:"network_id"`

	// Routes corresponds to the JSON schema field "routes".
	Routes []L3Ipv4NetworkRoute `json:"routes,omitempty" yaml:"routes,omitempty" mapstructure:"routes,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type L3Ipv4Type `json:"type" yaml:"type" mapstructure:"type"`
}

type L3Ipv4NetworkRoute struct {
	// Gateway corresponds to the JSON schema field "gateway".
	Gateway L3Ipv4Gateway `json:"gateway" yaml:"gateway" mapstructure:"gateway"`

	// Netmask corresponds to the JSON schema field "netmask".
	Netmask L3Ipv4Netmask `json:"netmask" yaml:"netmask" mapstructure:"netmask"`

	// Network corresponds to the JSON schema field "network".
	Network L3Ipv4Nw `json:"network" yaml:"network" mapstructure:"network"`

	// Services corresponds to the JSON schema field "services".
	Services Ipv4Services `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4NetworkRoute) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["gateway"]; raw != nil && !ok {
		return fmt.Errorf("field gateway in L3Ipv4NetworkRoute: required")
	}
	if _, ok := raw["netmask"]; raw != nil && !ok {
		return fmt.Errorf("field netmask in L3Ipv4NetworkRoute: required")
	}
	if _, ok := raw["network"]; raw != nil && !ok {
		return fmt.Errorf("field network in L3Ipv4NetworkRoute: required")
	}
	type Plain L3Ipv4NetworkRoute
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L3Ipv4NetworkRoute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Network) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in L3Ipv4Network: required")
	}
	if _, ok := raw["link"]; raw != nil && !ok {
		return fmt.Errorf("field link in L3Ipv4Network: required")
	}
	if _, ok := raw["network_id"]; raw != nil && !ok {
		return fmt.Errorf("field network_id in L3Ipv4Network: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in L3Ipv4Network: required")
	}
	type Plain L3Ipv4Network
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L3Ipv4Network(plain)
	return nil
}

type L3Ipv4Nw string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Nw) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv4Nw
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`)
	}
	*j = L3Ipv4Nw(plain)
	return nil
}

type L3Ipv4Type string

const L3Ipv4TypeIpv4 L3Ipv4Type = "ipv4"
const L3Ipv4TypeIpv4Dhcp L3Ipv4Type = "ipv4_dhcp"

var enumValues_L3Ipv4Type = []interface{}{
	"ipv4",
	"ipv4_dhcp",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv4Type) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L3Ipv4Type {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L3Ipv4Type, v)
	}
	*j = L3Ipv4Type(v)
	return nil
}

type L3Ipv6Gateway string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Gateway) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv6Gateway
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$`)
	}
	*j = L3Ipv6Gateway(plain)
	return nil
}

type L3Ipv6Host string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Host) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv6Host
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(/[0-9]{1,2})?$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(/[0-9]{1,2})?$`)
	}
	*j = L3Ipv6Host(plain)
	return nil
}

type L3Ipv6Netmask string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Netmask) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv6Netmask
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7})|(::))$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7})|(::))$`)
	}
	*j = L3Ipv6Netmask(plain)
	return nil
}

type L3Ipv6Network struct {
	// Id corresponds to the JSON schema field "id".
	Id L3Id `json:"id" yaml:"id" mapstructure:"id"`

	// IpAddress corresponds to the JSON schema field "ip_address".
	IpAddress *L3Ipv6Host `json:"ip_address,omitempty" yaml:"ip_address,omitempty" mapstructure:"ip_address,omitempty"`

	// Link corresponds to the JSON schema field "link".
	Link L3Link `json:"link" yaml:"link" mapstructure:"link"`

	// Netmask corresponds to the JSON schema field "netmask".
	Netmask *L3Ipv6Netmask `json:"netmask,omitempty" yaml:"netmask,omitempty" mapstructure:"netmask,omitempty"`

	// NetworkId corresponds to the JSON schema field "network_id".
	NetworkId L3NetworkId `json:"network_id" yaml:"network_id" mapstructure:"network_id"`

	// Routes corresponds to the JSON schema field "routes".
	Routes []L3Ipv6NetworkRoute `json:"routes,omitempty" yaml:"routes,omitempty" mapstructure:"routes,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type L3Ipv6Type `json:"type" yaml:"type" mapstructure:"type"`
}

type L3Ipv6NetworkRoute struct {
	// Gateway corresponds to the JSON schema field "gateway".
	Gateway L3Ipv6Gateway `json:"gateway" yaml:"gateway" mapstructure:"gateway"`

	// Netmask corresponds to the JSON schema field "netmask".
	Netmask L3Ipv6Netmask `json:"netmask" yaml:"netmask" mapstructure:"netmask"`

	// Network corresponds to the JSON schema field "network".
	Network L3Ipv6Nw `json:"network" yaml:"network" mapstructure:"network"`

	// Services corresponds to the JSON schema field "services".
	Services Ipv6Services `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6NetworkRoute) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["gateway"]; raw != nil && !ok {
		return fmt.Errorf("field gateway in L3Ipv6NetworkRoute: required")
	}
	if _, ok := raw["netmask"]; raw != nil && !ok {
		return fmt.Errorf("field netmask in L3Ipv6NetworkRoute: required")
	}
	if _, ok := raw["network"]; raw != nil && !ok {
		return fmt.Errorf("field network in L3Ipv6NetworkRoute: required")
	}
	type Plain L3Ipv6NetworkRoute
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L3Ipv6NetworkRoute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Network) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in L3Ipv6Network: required")
	}
	if _, ok := raw["link"]; raw != nil && !ok {
		return fmt.Errorf("field link in L3Ipv6Network: required")
	}
	if _, ok := raw["network_id"]; raw != nil && !ok {
		return fmt.Errorf("field network_id in L3Ipv6Network: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in L3Ipv6Network: required")
	}
	type Plain L3Ipv6Network
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = L3Ipv6Network(plain)
	return nil
}

type L3Ipv6Nw string

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Nw) UnmarshalJSON(value []byte) error {
	type Plain L3Ipv6Nw
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7})|(::))$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7})|(::))$`)
	}
	*j = L3Ipv6Nw(plain)
	return nil
}

type L3Ipv6Type string

const L3Ipv6TypeIpv6 L3Ipv6Type = "ipv6"
const L3Ipv6TypeIpv6Dhcp L3Ipv6Type = "ipv6_dhcp"
const L3Ipv6TypeIpv6Slaac L3Ipv6Type = "ipv6_slaac"

var enumValues_L3Ipv6Type = []interface{}{
	"ipv6",
	"ipv6_dhcp",
	"ipv6_slaac",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L3Ipv6Type) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L3Ipv6Type {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L3Ipv6Type, v)
	}
	*j = L3Ipv6Type(v)
	return nil
}

type L3Link string

type L3NetworkId string

// Schema of Nova instance network configuration information
type NetworkDataJson struct {
	// Links corresponds to the JSON schema field "links".
	Links []interface{} `json:"links" yaml:"links" mapstructure:"links"`

	// Networks corresponds to the JSON schema field "networks".
	Networks []interface{} `json:"networks" yaml:"networks" mapstructure:"networks"`

	// Services corresponds to the JSON schema field "services".
	Services Services `json:"services" yaml:"services" mapstructure:"services"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NetworkDataJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["links"]; raw != nil && !ok {
		return fmt.Errorf("field links in NetworkDataJson: required")
	}
	if _, ok := raw["networks"]; raw != nil && !ok {
		return fmt.Errorf("field networks in NetworkDataJson: required")
	}
	if _, ok := raw["services"]; raw != nil && !ok {
		return fmt.Errorf("field services in NetworkDataJson: required")
	}
	type Plain NetworkDataJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NetworkDataJson(plain)
	return nil
}

type Services []interface{}
